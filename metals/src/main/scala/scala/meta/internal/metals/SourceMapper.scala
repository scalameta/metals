package scala.meta.internal.metals

import java.net.URI
import java.nio.file.Paths

import scala.meta.inputs.Input
import scala.meta.internal.builds.SbtBuildTool
import scala.meta.internal.metals.MetalsEnrichments._
import scala.meta.internal.metals.ammonite.Ammonite
import scala.meta.internal.worksheets.WorksheetProvider
import scala.meta.io.AbsolutePath

import ch.epfl.scala.bsp4j.BuildTargetIdentifier
import org.eclipse.{lsp4j => l}

final case class SourceMapper(
    buildTargets: BuildTargets,
    buffers: Buffers,
    workspace: () => AbsolutePath
) {

  def mappedTo(
      path: AbsolutePath,
      targetOpt: Option[BuildTargetIdentifier]
  ): Option[AbsolutePath] =
    if (path.isAmmoniteScript) {
      for {
        target <- targetOpt.orElse(
          buildTargets.sourceBuildTargets(path).flatMap(_.headOption)
        )
        toIndex <- ammoniteScalaPath(target, path)
      } yield toIndex
    } else
      None

  def mappedTo(
      path: AbsolutePath
  ): Option[AbsolutePath] =
    mappedTo(path, None)

  def pcMapping(
      path: AbsolutePath,
      scalaVersion: String
  ): (Input.VirtualFile, l.Position => l.Position, AdjustLspData) = {

    def input = path.toInputFromBuffers(buffers)
    def default: (Input.VirtualFile, l.Position => l.Position, AdjustLspData) =
      (input, identity[l.Position] _, AdjustedLspData.default)

    val forScripts
        : Option[(Input.VirtualFile, l.Position => l.Position, AdjustLspData)] =
      if (path.isAmmoniteScript) {
        ammoniteInputPosOpt(path)
          .map { case (input, pos) =>
            (input, pos, Ammonite.adjustLspData(input.text))
          }
      } else if (path.isSbt) {
        buildTargets
          .sbtAutoImports(path)
          .map(
            SbtBuildTool.sbtInputPosAdjustment(input, _)
          )
      } else if (
        path.isWorksheet && ScalaVersions.isScala3Version(scalaVersion)
      ) {
        WorksheetProvider.worksheetScala3Adjustments(
          input,
          path.toURI.toASCIIString
        )
      } else None

    forScripts.getOrElse(default)
  }

  private def ammoniteInputPosOpt(
      path: AbsolutePath
  ): Option[(Input.VirtualFile, l.Position => l.Position)] =
    for {
      target <- buildTargets.inverseSources(path)
      res <- ammoniteScalaInputForPc(target, path)
    } yield res

  private def ammoniteScalaPath(
      targetId: BuildTargetIdentifier,
      source: AbsolutePath
  ): Option[AbsolutePath] =
    if (Ammonite.isAmmBuildTarget(targetId) && source.isAmmoniteScript)
      buildTargets.scalaTarget(targetId).map { target =>
        val rel = source.toRelative(workspace())
        val path = Paths
          .get(new URI(target.classDirectory))
          .getParent
          .resolve(
            s"src/ammonite/$$file/${rel.toString.stripSuffix(".sc")}.scala"
          )
        AbsolutePath(path.toAbsolutePath.normalize)
      }
    else
      None

  private def ammoniteScalaInputForPc(
      targetId: BuildTargetIdentifier,
      source: AbsolutePath
  ): Option[(Input.VirtualFile, l.Position => l.Position)] =
    ammoniteScalaPath(targetId, source)
      .map { scalaPath =>
        val scInput = source.toInputFromBuffers(buffers)
        val input = {
          val input0 = scalaPath.toInput
          // ensuring the path ends with ".sc.scala" so that the PC has a way to know
          // what we're giving it originates from an Ammonite script
          input0.copy(path = input0.path.stripSuffix(".scala") + ".sc.scala")
        }

        /*

        When given a script like

            case class Bar(xs: Vector[String])

        Ammonite generates a .scala file like

            package ammonite
            package $file

            import _root_.ammonite.interp.api.InterpBridge.{value => interp}

            object `main-1`{
              /*<script>*/case class Bar(xs: Vector[String])/*</script>*/ /*<generated>*/
              def $main() = { scala.Iterator[String]() }
              override def toString = "main$minus1"
              /*</generated>*/
            }

        When the script is being edited, we re-generate on-the-fly a valid .scala file ourselves
        from the one originally generated by Ammonite. The result should be a valid scala file, that
        we can pass to the PC.

        In order to update the .scala file above, we:
        - remove the section between '/*<generated>*/' and '/*</generated>*/'
        - replace the section between '/*<script>*/' and '/*</script>*/' by the new content of the script

         */

        val updatedContent = input.value
          .replaceAllBetween("/*<generated>*/", "/*</generated>*/")("")
          .replaceAllBetween("/*<script>*/", "/*</script>*/")(
            Ammonite.startTag + scInput.value
          )
        val updatedInput = input.copy(value = updatedContent)

        val scriptStartIdx =
          updatedContent.indexOf(Ammonite.startTag) + Ammonite.startTag.length
        val addedLineCount = updatedContent.lineAtIndex(scriptStartIdx)
        val updatePos: l.Position => l.Position = position =>
          new l.Position(
            addedLineCount + position.getLine,
            position.getCharacter
          )
        (updatedInput, updatePos)
      }
}
